<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL-01</title>
    <url>/2021/08/30/SQL/</url>
    <content><![CDATA[<h1 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL-1"></a>SQL-1</h1><h3 id="DB-Database"><a href="#DB-Database" class="headerlink" title="DB : Database"></a>DB : Database</h3><p>데이터를 통합하여 관리하는 데이터의 집합</p>
<h3 id="DBMS-Database-Management-System"><a href="#DBMS-Database-Management-System" class="headerlink" title="DBMS(Database Management System)"></a>DBMS(Database Management System)</h3><p>데이터 베이스를 관리하는 시스템</p>
<h3 id="RDBMS-Relational-Database-Management-System"><a href="#RDBMS-Relational-Database-Management-System" class="headerlink" title="RDBMS : Relational Database Management System"></a>RDBMS : Relational Database Management System</h3><p>Oracle, Mysql, Postgresql, Sqlite</p>
<p>데이터의 테이블 사이에 키값으로 관계를 가지고 있는 데이터베이스</p>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>Mongodb, Hbase, Cassandra</p>
<p>데이터 테이블 사이의 관계가 없이 데이터를 저장하는 DB.</p>
<p>데이터 사이의 관계가 없으므로 복잡성이 적고 많은 데이터의 저장이 가능.</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><p>MySQL은 오픈소스이며, 다중사용자와 다중 스레드 지원.</p>
<p>다양한 운영체제에 다양한 프로그래밍 언어 지원.</p>
<p>표준 SQL을 사용.</p>
<p>작고 강력하며 가격이 저렴.</p>
<p>AWS 우분투 연결</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -i ~Downloads/ssac.pem ubuntu@ip</span><br></pre></td></tr></table></figure>
<p>인스턴스 생성 시 받았던 비밀키랑, 퍼블릭 IP 사용</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update -y</span><br><span class="line">sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y mysql-server mysql-client</span><br><span class="line">sudo mysql</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>,authentication_string,plugin,host <span class="keyword">FROM</span> mysql.user;</span><br><span class="line">##비밀번호를 pwd로 변경(내부 패스워드 로컬)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;pwd&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">user</span>,authentication_string,plugin,host <span class="keyword">FROM</span> mysql.user;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ubuntu에서 이렇게 하고 패스워드 쳐서 mysql 접속</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"><span class="comment">#두번째 패스워드 생성//외부접속 패스워드, 인터넷으로 접속 할 때</span></span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment">#vim에서 /bind로 bind 검색 가능, shift-d 하면 </span></span><br><span class="line">커서 뒤 다 삭제</span><br><span class="line">여기서 bind-adress를 127.0.0.1을 0.0.0.0으로 변경</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#외부접속 패스워드 생성</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> root@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;pwd&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure>
<p>(PC)work bench(wb) → Internet → MySQL(server)</p>
<p>필요한 것</p>
<p>public ip, password</p>
<p>MySQL Workvench에서 MySQL Connection 옆에 + 버튼 누르고</p>
<p>Setup 에서 Connection Name 작성(SSAC)</p>
<p>Hostname(public IP), username 입력, PW는 아까 햇던 ssac</p>
<p>이때 username은 ubuntu가 아니라 root. mySQL 서버에 접속하는거이기 때문.</p>
<p>FIle → OPen SQL script 해서 데이터 불러오고</p>
<p>File → new model</p>
<p>주석</p>
<p>/<em> ㅇㅇㅇㅇ </em></p>
<p>— 한줄</p>
<p>`# &lt;- 얘도 workbench에서 지원해줌</p>
<p>heidiSQL → 가벼움(윈도우</p>
<p>Seuqelpro → 맥에서 가볍게 쓸때</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 03. Word2vec</title>
    <url>/2021/10/18/Ch03%20word2vec/</url>
    <content><![CDATA[<h3 id="기존-통계-기반-기법의-문제점"><a href="#기존-통계-기반-기법의-문제점" class="headerlink" title="기존 통계 기반 기법의 문제점"></a>기존 통계 기반 기법의 문제점</h3><ul>
<li>단어의 개수가 $N$개일 때 Co-occurence matrix의 크기는 $N \times N$으로 너무 큼.</li>
<li>SVD를 사용하여 차원 축소를 진행하는데, 이때 SVD를 적용하는 비용도 $O(n^3)$으로 너무 큼.</li>
</ul>
<h3 id="추론-기반-기법"><a href="#추론-기반-기법" class="headerlink" title="추론 기반 기법"></a>추론 기반 기법</h3><ul>
<li>Neural Network처럼 학습 데이터를 미니배치로 나눠서 순차적으로 학습.</li>
</ul>
<p><img src="/image/nlp-from-scratch/fig%203-1.png" alt="fig 3-1.png"></p>
<h2 id="CBOW-Continuous-Bag-Of-Words"><a href="#CBOW-Continuous-Bag-Of-Words" class="headerlink" title="CBOW(Continuous Bag-Of-Words)"></a>CBOW(Continuous Bag-Of-Words)</h2><ul>
<li>주변 단어의 맥락(context)이 주어졌을때 무슨 단어(target)가 들어갈지 추측하는 과정.</li>
</ul>
<p><img src="/image/nlp-from-scratch/fig%203-2.png" alt="fig 3-2.png"></p>
<ul>
<li>학습시 사용한 말뭉치(corpus)에 따라 얻게 되는 단어의 분산 표현이 다름.</li>
<li>가중치를 다시 학습할 수 있어서, 단어의 분산표현 갱신이나 새로운 단어 추가를 효육적으로 수행할 수 있음</li>
</ul>
<h3 id="학습-과정"><a href="#학습-과정" class="headerlink" title="학습 과정"></a>학습 과정</h3><p><img src="/image/nlp-from-scratch/fig%203-12.png" alt="fig 3-12.png"></p>
<ol>
<li>context, target을 one-hot vector로 변환</li>
<li>해당 vector들을 input 으로 넣음 (이 때 input layer의 개수는 입력시키는 단어의 개수와 같음)</li>
<li>hidden layer에서 각 input layer들의 값의 평균을 계산</li>
<li>Softmax를 통해 해당 단어가 해당 자리에 나타날 확률을 계산</li>
<li>Cross-entropy error를 통해 Loss 계산, 학습</li>
</ol>
<h3 id="가중치"><a href="#가중치" class="headerlink" title="가중치"></a>가중치</h3><ul>
<li>CBOW 모델에는 가중치가 2개 존재함</li>
</ul>
<p><img src="/image/nlp-from-scratch/fig%203-15.png" alt="fig 3-15.png"></p>
<ul>
<li>$W_{in}$의 각 행(row)이 각 단어의 분산표현을 나타냄</li>
<li>$W_{out}$에도 각 단어의 의미가 열(column)으로 저장됨</li>
<li>이 때 word2vec에서는 보통 $W_{in}$만 사용할 때 결과가 좋음(특히 skip-gram)</li>
<li>GloVE에서는 두 가중치를 더해서 사용했을 때 더 좋은 결과를 얻음</li>
</ul>
<h3 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h3><ul>
<li>CBOW와 다르게 target으로부터 주변 context를 추측하는 모델</li>
</ul>
<p><img src="/image/nlp-from-scratch/fig%203-23.png" alt="fig 3-23.png"></p>
<ul>
<li>CBOW보다 계산 비용이 크지만 corpus가 커질수록 성능이 뛰어난 경향을 보임.</li>
</ul>
<h3 id="통계-기반-vs-추론-기반"><a href="#통계-기반-vs-추론-기반" class="headerlink" title="통계 기반 vs 추론 기반"></a>통계 기반 vs 추론 기반</h3><ol>
<li>단어의 분산 표현을 수정하고 싶을 때<ul>
<li>통계 기반 기법은 co-occurence matrix를 새로 만들어야 하는 반면</li>
<li>추론 기반 기법(word2vec)은 기존 가중치를 초깃값으로 다시 학습하면 되기 때문에 효율적으로 갱신 가능함</li>
</ul>
</li>
<li>성능면에서는 통계 기반 / 추론 기반 기법의 우열을 따지기 어려움</li>
<li>두 기법은 연관이 있음<ul>
<li>skip-gram과 네거티브 샘플링을 이용한 모델은 co-occurence matrix에 특수한 행렬 분해를 적용한 것과 같음</li>
<li>GloVe : 두 기법을 융합한 기법</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>l</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch 02. 단어의 분산 표현</title>
    <url>/2021/10/16/Ch02%20%EB%8B%A8%EC%96%B4%EC%9D%98%20%EB%B6%84%EC%82%B0%ED%91%9C%ED%98%84/</url>
    <content><![CDATA[<h2 id="단어의-의미"><a href="#단어의-의미" class="headerlink" title="단어의 의미"></a>단어의 의미</h2><ul>
<li>자연어를 컴퓨터에게 이해시키기 위해서는 ‘단어의 의미’를 이해시키는 것이 중요함</li>
</ul>
<h3 id="단어의-의미를-표현하는-기법들"><a href="#단어의-의미를-표현하는-기법들" class="headerlink" title="단어의 의미를 표현하는 기법들"></a>단어의 의미를 표현하는 기법들</h3><ul>
<li>시소러스를 활용한 기법(WordNet)</li>
<li>통계 기반 기법(corpus)</li>
<li>추론 기반 기법(word2vec)</li>
</ul>
<h2 id="시소러스-thesaurus"><a href="#시소러스-thesaurus" class="headerlink" title="시소러스(thesaurus)"></a>시소러스(thesaurus)</h2><ul>
<li>WordNet 등의 시소러스를 이용하여 유의어를 얻거나, 단어사이의 유사도를 측정하는 등 유용한 작업을 할 수 있음</li>
<li>그러나 시소러스 기반 기법은 비용 문제나 새로운 단어에 대응이 어렵다는 문제가 있음</li>
</ul>
<h2 id="통계-기반-기법-Corpus"><a href="#통계-기반-기법-Corpus" class="headerlink" title="통계 기반 기법 - Corpus"></a>통계 기반 기법 - Corpus</h2><ul>
<li>그 결과 현재는 말뭉치(corpus)를 이용해 vectorization하는 방법을 주로 사용</li>
<li>분포 가설(distributional hypothesis) : ‘단어의 의미는 주변 단어에 의해 형성된다’는 가설</li>
</ul>
<h3 id="동시발생-행렬-co-occurence-matrix"><a href="#동시발생-행렬-co-occurence-matrix" class="headerlink" title="동시발생 행렬(co-occurence matrix)"></a>동시발생 행렬(co-occurence matrix)</h3><ul>
<li>각 말뭉치 안의 각 단어에 대해 주변 단어의 빈도를 집계</li>
<li>Cosine similarity로 단어 벡터간 유사도 계산</li>
</ul>
<h3 id="PPMI-Positive-Pointwise-Mutual-Information"><a href="#PPMI-Positive-Pointwise-Mutual-Information" class="headerlink" title="PPMI(Positive Pointwise Mutual Information)"></a>PPMI(Positive Pointwise Mutual Information)</h3><ul>
<li>PPMI : ‘a’, ‘the’ 처럼 단어와 관련성이 적지만 동시에 자주 발생하는 경우를 고려<ul>
<li>PPMI의 경우 차원수가 corpus의 어휘 수와 같으므로 차원수가 너무 커지는 문제가 있음</li>
<li>SVD를 통해 차원축소</li>
</ul>
</li>
<li>PTB dataset을 통해 테스트</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>from-scratch</tag>
      </tags>
  </entry>
  <entry>
    <title>Practice Posting</title>
    <url>/2021/08/26/Practice-Posting/</url>
    <content><![CDATA[<h1 id="First-Post"><a href="#First-Post" class="headerlink" title="First Post"></a>First Post</h1><h2 id="Writing-Markdown-with-Git-Bash-is-too-hard"><a href="#Writing-Markdown-with-Git-Bash-is-too-hard" class="headerlink" title="Writing Markdown with Git Bash is too hard."></a>Writing Markdown with Git Bash is too hard.</h2><ul>
<li>Want to write Markdown in Jupyter Notebook</li>
<li>주피터 노트북은 바로바로 결과를 볼 수 있어서 쓰기 편한데</li>
<li>Git Bast에 바로 쓰는건 이게 코드만 보고 잘 적용이 됐는지 안보여서 불편함</li>
<li><script type="math/tex; mode=display">x+1 = 2</script></li>
<li><script type="math/tex; mode=display">
  \sqrt{3x-1}+(1+x)^2</script></li>
<li><p>$ x+1 = 2y $</p>
</li>
</ul>
<p>  $x+1=2y$</p>
<script type="math/tex; mode=display">( a^2 )</script><p>이런게 잘 들어가는지<br>Hexo를 통해 문서를 작성하고 나면 <code>hexo clean &amp;&amp; generate</code>를 해준 다음<br><code>hexo deploy</code>로 서버?에 배포?해준다.</p>
<h2 id="ㅜㅜ"><a href="#ㅜㅜ" class="headerlink" title="ㅜㅜ"></a>ㅜㅜ</h2><ul>
<li>주피터노트북 상에서 작업하고 거기서 연동해서 바로 블로그에 올릴수는 없을까.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>1-1 데이터와 정보</title>
    <url>/2021/09/21/%EB%B9%85%EB%B6%84%EA%B8%B0-1-1-1-data/</url>
    <content><![CDATA[<h1 id="빅데이터-개요-및-활용"><a href="#빅데이터-개요-및-활용" class="headerlink" title="빅데이터 개요 및 활용"></a>빅데이터 개요 및 활용</h1><h1 id="1-데이터와-정보"><a href="#1-데이터와-정보" class="headerlink" title="1. 데이터와 정보"></a>1. 데이터와 정보</h1><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><ul>
<li>데이터는 현실 세계에서 관찰/측정하여 수집하한 사실로 추론과 추정의 근거를 이룸</li>
<li>단순한 객체로도 가치가 있으며, 다른 객체와의 상호관계 속에서 더 큰 가치를 가짐</li>
<li>객관적 사실이라는 존재적 특성</li>
<li>추론, 추정, 예측, 전망을 위한 근거로써 당위적 특성을 가짐</li>
</ul>
<h3 id="데이터의-구분"><a href="#데이터의-구분" class="headerlink" title="데이터의 구분"></a>데이터의 구분</h3><ol>
<li><p>정량적 데이터(Quantitative Data)</p>
<ul>
<li>주로 숫자로 이루어진 데이터</li>
<li>Ex) 2021년, 100km/h 등</li>
</ul>
</li>
<li><p>정성적 데이터(Qualitative Data)</p>
<ul>
<li>문자와 같은 텍스트로 구성, 함축적 의미를 지닌 데이터</li>
<li>ex) 철수가 시험에 합격하였다.</li>
</ul>
</li>
</ol>
<h3 id="데이터의-유형"><a href="#데이터의-유형" class="headerlink" title="데이터의 유형"></a>데이터의 유형</h3><ol>
<li><p>정형 데이터(Structured Data)</p>
<ul>
<li>정해진 형식과 구조에 맞게 저장</li>
<li>연산이 가능함</li>
<li>Ex) 관계형 DB의 테이블에 저장되는 데이터</li>
</ul>
</li>
<li><p>반정형 데이터(Semi-structured Data)</p>
<ul>
<li>데이터의 형식과 구조가 비교적 유연함</li>
<li>스키마 정보를 데이터와 함께 제공하는 형식의 데이터</li>
<li>연산이 불가능</li>
<li>Ex) JSON, XML, RDF, HTML 등</li>
</ul>
</li>
<li><p>비정형 데이터(Unstructured Data)</p>
<ul>
<li>구조가 정해지지 않은 대부분의 데이터</li>
<li>연산이 불가능</li>
<li>Ex) 동영상, 이미지, 음성, 문서, 메일 등</li>
</ul>
</li>
</ol>
<p><a href="https://www.notion.so/9fba6c5af1bd48628eb304960939203c">정량적 vs 정성적</a></p>
<h3 id="데이터의-근원에-따른-분류"><a href="#데이터의-근원에-따른-분류" class="headerlink" title="데이터의 근원에 따른 분류"></a>데이터의 근원에 따른 분류</h3><ol>
<li><p>가역 데이터</p>
<ul>
<li>데이터의 원본으로 일정 수준 환원이 가능한 데이터</li>
<li>이력 추적이 가능, 원본 데이터의 변경사항 반영 가능</li>
</ul>
</li>
<li><p>불가역 데이터</p>
<ul>
<li>원본으로 환원이 불가능한 데이터</li>
<li><p>원본 데이터와는 전혀 다른 형태로 재생산, 변경사항 반영 불가</p>
<p><a href="https://www.notion.so/59ba84f58c0445fdbaa31a0948f01704">가역 vs 불가역</a></p>
</li>
</ul>
</li>
</ol>
<h3 id="데이터의-기능"><a href="#데이터의-기능" class="headerlink" title="데이터의 기능"></a>데이터의 기능</h3><p>데이터를 기반으로 한 암묵지와 형식지의 상호작용이 중요</p>
<ol>
<li><p>암묵지</p>
<ul>
<li>어떠한 시행착오나 경험을 통해 개인에게 체계화 된 지식</li>
<li>겉으로 드러나지 않고, 전달과 공유가 어려움</li>
</ul>
</li>
<li><p>형식지</p>
<ul>
<li>형상화된 유형의 지식</li>
<li>전달과 공유가 쉬움</li>
</ul>
</li>
</ol>
<h3 id="지식-창조-매커니즘"><a href="#지식-창조-매커니즘" class="headerlink" title="지식 창조 매커니즘"></a>지식 창조 매커니즘</h3><p>암묵지와 형식지 간 상호작용을 위한 지식창조 매커니즘</p>
<ol>
<li><p>공통화(Socialization)</p>
<ul>
<li>서로의 경험이나 인식을 공유하며 한 차원 높은 암묵지로 발전</li>
</ul>
</li>
<li><p>표출화(Externalization)</p>
<ul>
<li>암묵지가 구체화되어 외부(형식지)로 표현</li>
</ul>
</li>
<li><p>연결화(Combination)</p>
<ul>
<li>형식지를 재분류하여 체계화</li>
</ul>
</li>
<li><p>내면화(Internalization)</p>
<ul>
<li>전달받은 형식지를 다시 개인의 것으로 만듬</li>
</ul>
</li>
</ol>
<p>공통화 → 표출화 → 연결화 → 내면화 → 공통화 ———&gt; ….</p>
<h3 id="데이터-정보-지식-지혜"><a href="#데이터-정보-지식-지혜" class="headerlink" title="데이터, 정보, 지식 지혜"></a>데이터, 정보, 지식 지혜</h3><p>지식의 피라미드 : 데이터 → 정보 → 지식 → 지혜</p>
<ol>
<li><p>데이터(Data) </p>
<ul>
<li>현실에서 관찰하거나 측정하여 수집한 사실이나 값 / 객관적 사실</li>
<li>Ex) 온라인 쇼핑 시 노트북 가격은 100만원이며, 오프라인에서는 150만원이다.</li>
</ul>
</li>
<li><p>정보(Information) </p>
<ul>
<li>데이터를 가공하거나 처리하여 도출한 의미</li>
<li>Ex) 오프라인 상점보다 온라인 쇼핑 시 노트북 가격이 더 저렴하다.</li>
</ul>
</li>
<li><p>지식(Knowledge)</p>
<ul>
<li>상호 연결된 정보를 구조화하여 유의미한 정보를 분류</li>
<li>개인적인 경험을 결합시켜 내재화한 고유의 결과물</li>
<li>Ex) 오프라인 보다 저렴한 온라인으로 노트북을 구매할 것이다</li>
</ul>
</li>
<li><p>지혜(Wisdom)</p>
<ul>
<li>축적된 지식을 통해 근본적인 원리를 이해하고 아이디어를 결합하여 도출한 창의적 산물</li>
<li>Ex) 다른 상품들도 온라인 쇼핑 시 오프라인보다 저렴할 것이다.</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>빅분기 필기</category>
      </categories>
      <tags>
        <tag>Big data</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>빅분기 1-1-2 Database</title>
    <url>/2021/09/25/%EB%B9%85%EB%B6%84%EA%B8%B0-1-1-2%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/</url>
    <content><![CDATA[<h1 id="1-1-2-데이터베이스"><a href="#1-1-2-데이터베이스" class="headerlink" title="1-1-2 데이터베이스"></a>1-1-2 데이터베이스</h1><h1 id="2-데이터베이스"><a href="#2-데이터베이스" class="headerlink" title="2. 데이터베이스"></a>2. 데이터베이스</h1><h3 id="데이터베이스-관리-시스템-DBMS-DataBase-Management-System"><a href="#데이터베이스-관리-시스템-DBMS-DataBase-Management-System" class="headerlink" title="데이터베이스 관리 시스템(DBMS: DataBase Management System)"></a>데이터베이스 관리 시스템(DBMS: DataBase Management System)</h3><ol>
<li>관계형 DBMS : 데이터를 열과 행을 이루는 테이블로 표현</li>
<li>객체지향 DBMS : 정보를 객체 형태로 표현</li>
<li>네트워크 DBMS : 그래프 구조를 기반으로 하는 모델</li>
<li>계층형 DMBS : 트리 구조를 기반으로 하는 모델</li>
</ol>
<h3 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL (Structured Query Language)"></a>SQL (Structured Query Language)</h3><ul>
<li>DB에 접근할 때 사용하는 언어</li>
<li>데이터의 정의와 조작 기능을 가지고 있음</li>
<li>테이블 단위로 연산을 수행. 사용하기 쉬움</li>
</ul>
<h3 id="DB의-특징"><a href="#DB의-특징" class="headerlink" title="DB의 특징"></a>DB의 특징</h3><ol>
<li>통합된 데이터(Integrated Data)<ul>
<li>동일한 데이터가 중복되어 저장되지 않음을 의미</li>
<li>데이터의 중복은 관리상 복잡하고 다양한 문제를 초래함</li>
</ul>
</li>
<li>저장된 데이터(Stored Data)<ul>
<li>컴퓨터가 접근할 수 있는 저장매체에 데이터를 저장</li>
</ul>
</li>
<li>공용 데이터(Shared Data)<ul>
<li>여러 사용자가 서로 다른 목적으로 데이터를 함께 이용</li>
</ul>
</li>
<li>변화되는 데이터(Changed Data)<ul>
<li>지속적으로 갱신되면서도 현재의 정확한 데이터를 유지해야 함</li>
</ul>
</li>
</ol>
<p><a href="1-1-2%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%206d578a437b4844228df6d417dcdc87df/DB%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B4%20%E1%84%89%E1%85%A1%E1%84%87%E1%85%A9%E1%86%AB%2074bec8f976004579b4295aa517dc3099.csv">DB의 장단점</a></p>
<h3 id="DB의-활용"><a href="#DB의-활용" class="headerlink" title="DB의 활용"></a>DB의 활용</h3><ol>
<li>OLTP(OnLine Transacction Processing)</li>
</ol>
<ul>
<li>데이터 갱신 위주</li>
</ul>
<ol>
<li>OLAD(OnLine Analytical Precessing</li>
</ol>
<ul>
<li>데이터 조회 위주</li>
</ul>
<p><a href="1-1-2%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%206d578a437b4844228df6d417dcdc87df/%E1%84%8C%E1%85%A6%E1%84%86%E1%85%A9%E1%86%A8%20%E1%84%8B%E1%85%A5%E1%86%B9%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20a5e5a5be7ff34f538341c582656ce238.csv">제목 없음</a></p>
<h3 id="데이터-웨어하우스"><a href="#데이터-웨어하우스" class="headerlink" title="데이터 웨어하우스"></a>데이터 웨어하우스</h3>]]></content>
      <categories>
        <category>빅분기 필기</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>bigdata</tag>
      </tags>
  </entry>
</search>
